<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Weather4Sports
    </title>
    <style>
        :root {
            --bg: #0f1724;
            --card: #0b1220;
            --muted: #98a0b3;
            --accent: #4f46e5
        }

        * {
            box-sizing: border-box
        }

        body {
            font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
            margin: 0;
            background: linear-gradient(180deg, #071026 0%, #07172a 100%);
            color: #e6eef8;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px
        }

        .app {
            width: 100%;
            max-width: 900px
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 20px;
            margin: 0
        }

        p.lead {
            margin: 4px 0 0;
            color: var(--muted);
            font-size: 13px
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            border-radius: 14px;
            padding: 18px;
            margin-top: 18px;
            box-shadow: 0 6px 30px rgba(2, 6, 23, 0.6)
        }

        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            color: inherit;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .btn:hover {
            background-color: rgba(255,255,255,0.05);
        }

        .btn.primary {
            background: linear-gradient(90deg, var(--accent), #7c3aed);
            border: none
        }

        .row {
            display: flex;
            gap: 14px;
            flex-wrap: wrap
        }

        .col {
            flex: 1;
            min-width: 220px
        }

        .metric {
            display: flex;
            align-items: center;
            gap: 12px
        }

        .big {
            font-size: 36px;
            font-weight: 700;
            transition: opacity 0.4s ease;
        }

        .muted {
            color: var(--muted)
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 12px;
            margin-top: 12px
        }

        .stat {
            background: rgba(255, 255, 255, 0.02);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.2s ease, background-color 0.2s ease;
        }
        .stat:hover {
            transform: translateY(-3px);
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pill {
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.03);
            transition: background-color 0.4s ease, opacity 0.4s ease;
        }

        .sport-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px
        }

        .sport {
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.04);
            transition: border-color 0.2s ease, background-color 0.2s ease;
        }
        .sport:not(.active):hover {
            border-color: rgba(255,255,255,0.1);
        }

        .sport.active {
            background: rgba(79, 70, 229, 0.12);
            border-color: rgba(79, 70, 229, 0.3)
        }

        footer {
            margin-top: 12px;
            color: var(--muted);
            font-size: 13px
        }

        input[type="number"], input[type="text"] {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            background: transparent;
            color: inherit;
        }

        input[type="number"] { width: 120px; }
        input[type="text"] { width: 180px; }
        
        #forecast { margin-top: 24px; }
        #forecast h2 { margin-bottom: 8px; }
        .forecast-day { background: rgba(255,255,255,0.05); border-radius: 10px; padding: 10px; margin-bottom: 8px; }

        #hourly-scroll-container { overflow-x: auto; white-space: nowrap; padding-bottom: 12px; }
        #hourly-content { display: flex; gap: 12px; }
        .hourly-item { flex-shrink: 0; width: 75px; padding: 12px 8px; border-radius: 10px; background: rgba(255, 255, 255, 0.03); text-align: center; font-size: 13px; }
        .hourly-icon { font-size: 24px; margin: 4px 0; }
        .hourly-score { font-size: 12px; padding: 2px 6px; border-radius: 999px; margin-top: 4px; font-weight: 500; transition: background-color 0.4s ease; }
        #hourly-scroll-container::-webkit-scrollbar { height: 6px; }
        #hourly-scroll-container::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 3px; }
        #hourly-scroll-container::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }

        .rain-alert { background-color: rgba(6, 78, 117, 0.5); border: 1px solid rgba(14, 165, 233, 0.4); padding: 12px; border-radius: 10px; margin-bottom: 18px; font-weight: 500;}
        
        #save-fav-btn { background: none; border: none; cursor: pointer; font-size: 18px; padding: 0 4px; transition: color 0.2s ease; color: var(--muted); }
        #save-fav-btn.is-favorite { color: #eab308; }

        #favorites-section .btn { font-size: 13px; padding: 6px 10px; }
        #favorites-section .delete-btn { color: #ffb4b4; padding: 6px 8px; }
        
        .explain { margin-top: 10px; color: var(--muted); font-size: 13px; font-style: italic; }

    </style>
</head>

<body>
    <div class="app">
        <header>
            <div>
                <h1>Weather4Sports</h1>
                <p class="lead">Get sport-specific weather ratings for your location.</p>
            </div>
            <div class="controls">
                <input type="text" id="city-search" placeholder="Search for a city..." list="city-suggestions">
                <datalist id="city-suggestions"></datalist>
                <button class="btn" id="refresh">üîÑ My Location</button>
                <label class="pill muted">Units: <select id="units">
                        <option value="metric">Metric (¬∞C, km/h)</option>
                        <option value="imperial" selected>Imperial (¬∞F, mph)</option>
                    </select></label>
            </div>
        </header>

        <div class="card">
            <div id="rain-alert" class="rain-alert" style="display: none;"></div>
            <div class="row">
                <div class="col">
                    <div class="metric">
                        <div>
                            <div id="temp" class="big">--¬∞</div>
                            <div class="muted" id="desc">--</div>
                        </div>
                        <div style="margin-left:auto;text-align:right">
                            <div class="muted">Location</div>
                            <div id="loc-container" style="display:flex; align-items:center; gap: 4px; justify-content: flex-end;">
                                <span id="loc">detecting‚Ä¶</span>
                                <button id="save-fav-btn" style="display: none;">‚òÜ</button>
                            </div>
                            <div class="muted" style="font-size:12px" id="time">--</div>
                        </div>
                    </div>

                    <div class="stat-grid" id="stats">
                        <div class="stat">Wind<br><strong id="wind">--</strong></div>
                        <div class="stat">Precip<br><strong id="precip">--</strong></div>
                        <div class="stat">Humidity<br><strong id="hum">--</strong></div>
                        <div class="stat">Clouds<br><strong id="clouds">--</strong></div>
                        <div class="stat">Feels Like<br><strong id="feels">--</strong></div>
                        <div class="stat">Pressure<br><strong id="press">--</strong></div>
                        <div class="stat">UV Index<br><strong id="uv">--</strong></div>
                        <div class="stat">Visibility<br><strong id="vis">--</strong></div>
                        <div class="stat">Sunrise<br><strong id="sunrise">--</strong></div>
                        <div class="stat">Sunset<br><strong id="sunset">--</strong></div>
                    </div>

                </div>
                <div class="col">
                    <div class="muted">Sport</div>
                    <div class="sport-list" id="sports">
                        <div class="sport active" data-sport="basketball">üèÄ Basketball</div>
                        <div class="sport" data-sport="soccer">‚öΩ Soccer</div>
                        <div class="sport" data-sport="tennis">üéæ Tennis</div>
                        <div class="sport" data-sport="baseball">‚öæ Baseball</div>
                        <div class="sport" data-sport="running">üèÉ Running</div>
                    </div>

                    <div style="margin-top:12px">
                        <div class="muted">Playability</div>
                        <div style="display:flex;align-items:center;gap:12px;margin-top:8px">
                            <div id="play-badge" class="pill">--</div>
                            <div class="muted" id="score">Score: --/100</div>
                        </div>
                        <div id="reason" class="explain"></div>
                    </div>

                    <div style="margin-top:14px">
                        <div class="muted">Good Play Windows Today</div>
                        <div id="play-windows" style="font-weight:bold; color: #a5f3fc; margin-top: 4px;">Analyzing...</div>
                    </div>
                </div>
            </div>

            <div id="hourly-forecast-section" class="card" style="padding-top: 12px;">
                <h2 style="margin-top:0; margin-bottom: 12px;">Hourly Forecast</h2>
                <div id="hourly-scroll-container">
                    <div id="hourly-content"></div>
                </div>
            </div>

            <div id="forecast" class="card">
                <h2>3-Day Playability Forecast</h2>
                <div id="forecast-content">Loading forecast...</div>
            </div>
            
            <div id="favorites-section" class="card"></div>

            <div style="margin-top:14px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
                <div class="muted">Manual coords</div>
                <input type="number" id="lat" placeholder="lat" step="0.0001">
                <input type="number" id="lon" placeholder="lon" step="0.0001">
                <button class="btn primary" id="apply-coords">Apply</button>
                <div id="status" style="margin-left:auto" class="muted">API: Open-Meteo</div>
            </div>
        </div>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const unitsSelect = $('units');
        const scoreEl = $('score');
        const playBadge = $('play-badge');
        const forecastContent = $('forecast-content');
        
        let units = unitsSelect.value;
        let lastData = null;

        const sportsConfig = {
            basketball: { weights: { temp: 0.4, wind: 0.2, humidity: 0.1, uv: 0.2, visibility: 0.1 }, idealTemp: [15, 28], precipPenaltyFactor: 0.25 },
            soccer:     { weights: { temp: 0.3, wind: 0.2, humidity: 0.1, clouds: 0.1, uv: 0.15, visibility: 0.15 }, idealTemp: [10, 25], precipPenaltyFactor: 1.5 },
            tennis:     { weights: { temp: 0.3, wind: 0.3, humidity: 0.1, uv: 0.15, visibility: 0.15 }, idealTemp: [12, 30], precipPenaltyFactor: 0.25 },
            baseball:   { weights: { temp: 0.3, wind: 0.2, humidity: 0.1, clouds: 0.1, uv: 0.1, visibility: 0.2 }, idealTemp: [12, 32], precipPenaltyFactor: 0.5 },
            running:    { weights: { temp: 0.4, wind: 0.2, humidity: 0.2, uv: 0.2 }, idealTemp: [8, 20], precipPenaltyFactor: 2.5 }
        };

        let selectedSport = 'basketball';

        unitsSelect.addEventListener('change', () => {
            units = unitsSelect.value;
            if (lastData) render(lastData);
        });

        document.querySelectorAll('.sport').forEach(el => el.addEventListener('click', () => {
            document.querySelectorAll('.sport').forEach(s => s.classList.remove('active'));
            el.classList.add('active');
            selectedSport = el.dataset.sport;
            if (lastData) render(lastData);
        }));

        $('refresh').addEventListener('click', getLocationAndFetch);
        $('apply-coords').addEventListener('click', () => {
            const lat = parseFloat($('lat').value);
            const lon = parseFloat($('lon').value);
            if (Number.isFinite(lat) && Number.isFinite(lon)) fetchWeather(lat, lon);
            else alert('Please enter valid coordinates.');
        });
        
        const searchInput = $('city-search');
        const suggestionsList = $('city-suggestions');

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }
        
        const handleSearchInput = async (event) => {
            const query = event.target.value;
            if (query.length < 3) {
                suggestionsList.innerHTML = '';
                return;
            }

            const selectedOption = Array.from(suggestionsList.options).find(opt => opt.value === query);
            if (selectedOption) {
                const lat = parseFloat(selectedOption.dataset.lat);
                const lon = parseFloat(selectedOption.dataset.lon);
                const name = selectedOption.dataset.name;
                fetchWeather(lat, lon, name);
                suggestionsList.innerHTML = '';
                searchInput.value = '';
                return;
            }

            try {
                const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5`;
                const response = await fetch(url);
                const data = await response.json();
                suggestionsList.innerHTML = '';
                if (data.results) {
                    data.results.forEach(location => {
                        const option = document.createElement('option');
                        const region = location.admin1 || '';
                        const country = location.country_code;
                        option.value = `${location.name}${region ? ', ' + region : ''}, ${country}`;
                        option.dataset.lat = location.latitude;
                        option.dataset.lon = location.longitude;
                        option.dataset.name = location.name;
                        suggestionsList.appendChild(option);
                    });
                }
            } catch (e) {
                console.error("Geocoding fetch failed:", e);
            }
        };

        searchInput.addEventListener('input', debounce(handleSearchInput, 300));

        function getLocationAndFetch() {
            if (!navigator.geolocation) {
                $('status').textContent = 'Geolocation unavailable.';
                return;
            }
            $('loc').textContent = 'Getting location‚Ä¶';
            navigator.geolocation.getCurrentPosition(
                pos => fetchWeather(pos.coords.latitude, pos.coords.longitude),
                err => {
                    $('status').textContent = 'Location denied.';
                    alert('Location access was denied. Please use the search bar or enter coordinates manually.');
                }
            );
        }

        async function fetchWeather(lat, lon, locationName = null) {
            const elementsToFade = ['temp', 'play-badge', 'score'];
            elementsToFade.forEach(id => $(id).style.opacity = 0);
            
            $('status').textContent = 'Fetching weather‚Ä¶';
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,apparent_temperature,relativehumidity_2m,precipitation,cloudcover,windspeed_10m,surface_pressure,uv_index,visibility,weathercode&daily=sunrise,sunset&timezone=auto`;
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error('Weather API error');
                const data = await res.json();
                lastData = { data, lat: parseFloat(lat), lon: parseFloat(lon), name: locationName };
                render(lastData);
                $('status').textContent = `Updated ${new Date().toLocaleTimeString()}`;
            } catch (e) {
                console.error("Error during weather fetch or render:", e);
                $('status').textContent = 'Weather fetch or render failed.';
            } finally {
                elementsToFade.forEach(id => $(id).style.opacity = 1);
            }
        }
        
        function calculatePlayability(hourlyData, config, hourIndex) {
             if (hourIndex === undefined || hourIndex < 0 || !hourlyData) return 0;
             const requiredKeys = ['temperature_2m', 'precipitation', 'windspeed_10m', 'relativehumidity_2m', 'cloudcover', 'uv_index', 'visibility', 'weathercode'];
             if (requiredKeys.some(key => !hourlyData[key] || hourlyData[key].length <= hourIndex)) return 0;

             const tempC = hourlyData.temperature_2m[hourIndex];
             const precip_mm = hourlyData.precipitation[hourIndex];
             const wind_kmh = hourlyData.windspeed_10m[hourIndex];
             const hum = hourlyData.relativehumidity_2m[hourIndex];
             const clouds = hourlyData.cloudcover[hourIndex];
             const uv = hourlyData.uv_index[hourIndex];
             const visibility_m = hourlyData.visibility[hourIndex];
             const weatherCode = hourlyData.weathercode[hourIndex];

             if ([tempC, precip_mm, wind_kmh, hum, clouds, uv, visibility_m, weatherCode].some(v => v === undefined || v === null)) return 0;
             
             const dealBreakerCodes = [ 56, 57, 66, 67, 71, 73, 75, 77, 85, 86, 96, 99 ]; 
             const precipPenaltyFactor = config.precipPenaltyFactor || 2.0;
             let precipMultiplier = dealBreakerCodes.includes(weatherCode) ? 0 : Math.max(0, 1 - (precip_mm / precipPenaltyFactor));

             const runnableSnowCodes = [71, 73, 85];
             if (selectedSport === 'running' && runnableSnowCodes.includes(weatherCode)) {
                precipMultiplier = 0.3;
             }

             if (precipMultiplier === 0) return 0;

             let tempScore = 0;
             if (tempC < config.idealTemp[0]) tempScore = Math.max(0, 1 - (config.idealTemp[0] - tempC) / 15);
             else if (tempC > config.idealTemp[1]) tempScore = Math.max(0, 1 - (tempC - config.idealTemp[1]) / 15);
             else tempScore = 1;

             let windScore = wind_kmh > 35 ? 0 : 1 - wind_kmh / 35;
             let humScore = (hum >= 40 && hum <= 60) ? 1 : 1 - Math.min(Math.abs(hum - 50) / 50, 1);
             let cloudsScore = clouds > 100 ? 0 : 1 - clouds / 100;
             let uvScore = uv < 3 ? 1 : (uv > 11 ? 0 : 1 - ((uv - 3) / 8));
             const vis_km = visibility_m / 1000;
             let visibilityScore = vis_km > 10 ? 1 : (vis_km < 1 ? 0 : (vis_km - 1) / 9);
             
             let weightedSum = 0;
             let totalWeight = 0;
             for (const factor in config.weights) {
                let score = 0;
                if (factor === 'temp') score = tempScore;
                if (factor === 'wind') score = windScore;
                if (factor === 'humidity') score = humScore;
                if (factor === 'clouds') score = cloudsScore;
                if (factor === 'uv') score = uvScore;
                if (factor === 'visibility') score = visibilityScore;
                
                weightedSum += score * config.weights[factor];
                totalWeight += config.weights[factor];
             }
             
             const baseScore = totalWeight > 0 ? (weightedSum / totalWeight) : 1;
             const finalScore = baseScore * precipMultiplier;
             
             return Math.round(finalScore * 100);
        }

        // --- NEW: Generates the text reason for the current score ---
        function generateReasonText(hourlyData, config, index) {
            const score = calculatePlayability(hourlyData, config, index);

            if (score >= 80) {
                return `‚úÖ Conditions are ideal for ${selectedSport}.`;
            }

            const tempC = hourlyData.temperature_2m[index];
            const precip_mm = hourlyData.precipitation[index];
            const wind_kmh = hourlyData.windspeed_10m[index];
            const hum = hourlyData.relativehumidity_2m[index];
            const uv = hourlyData.uv_index[index];
            const visibility_m = hourlyData.visibility[index];
            const weatherCode = hourlyData.weathercode[index];
            const vis_km = visibility_m / 1000;
            
            const reasons = [];
            if (tempC > config.idealTemp[1]) reasons.push('high temperature');
            if (tempC < config.idealTemp[0]) reasons.push('low temperature');
            const isSnowing = [71, 73, 75, 77, 85, 86].includes(weatherCode);
            if (precip_mm > 0.1 && isSnowing) reasons.push('snow');
            else if (precip_mm > 0.1) reasons.push('rain');
            if (wind_kmh > 25) reasons.push('strong wind');
            if (hum < 30 || hum > 80) reasons.push('humidity');
            if (uv > 7) reasons.push('high UV index');
            if (vis_km < 2) reasons.push('poor visibility');

            if (reasons.length === 0 && score < 80) {
                 return `üëç Conditions are generally good for ${selectedSport}.`;
            }
            
            const prefix = score >= 50 ? 'Fair conditions:' : 'Poor conditions due to:';
            return `${prefix} ${reasons.join(', ')}.`;
        }


        function findPlayWindows(hourlyData, config, startIndex) {
            if (!hourlyData.time || !hourlyData.time[startIndex]) return 'Not enough data.';
            
            const todayStr = hourlyData.time[startIndex].split('T')[0];
            const goodHours = [];

            for (let i = startIndex; i < hourlyData.time.length; i++) {
                const date = new Date(hourlyData.time[i]);
                const hour = date.getHours();
                const currentDayStr = hourlyData.time[i].split('T')[0];

                if (currentDayStr !== todayStr) break;

                if (hour >= 6 && hour <= 21) {
                    const score = calculatePlayability(hourlyData, config, i);
                    if (score >= 80) {
                        goodHours.push(hour);
                    }
                }
            }

            if (goodHours.length === 0) {
                return 'No ideal windows left today.';
            }

            const windows = [];
            let currentWindow = [];
            for (let i = 0; i < goodHours.length; i++) {
                if (i > 0 && goodHours[i] !== goodHours[i - 1] + 1) {
                    windows.push(currentWindow);
                    currentWindow = [];
                }
                currentWindow.push(goodHours[i]);
            }
            if (currentWindow.length > 0) windows.push(currentWindow);

            return windows.map(window => {
                const formatOptions = { hour: 'numeric', hour12: true };
                const startTime = new Date();
                startTime.setHours(window[0], 0, 0);

                if (window.length > 1) {
                    const endTime = new Date();
                    endTime.setHours(window[window.length - 1] + 1, 0, 0);
                    return `${startTime.toLocaleTimeString([], formatOptions).replace(/\s/g, '')} - ${endTime.toLocaleTimeString([], formatOptions).replace(/\s/g, '')}`;
                } else {
                    return startTime.toLocaleTimeString([], formatOptions).replace(/\s/g, '');
                }
            }).join(', ');
        }

        function render(payload) {
            const { data, lat, lon, name } = payload;
            
            if (!data || !data.current_weather || !data.hourly || !data.hourly.time || data.hourly.time.length === 0) {
                $('status').textContent = 'Incomplete weather data received.';
                return;
            }
            
            const cw = data.current_weather;
            const hourly = data.hourly;
            const daily = data.daily;
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const isoHour = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:00`;
            let idx = hourly.time.indexOf(isoHour);
            if (idx === -1) idx = 0;

            const tempC = hourly.temperature_2m[idx];
            const feelsC = hourly.apparent_temperature[idx];
            const hum = hourly.relativehumidity_2m[idx];
            const precip_mm = hourly.precipitation[idx];
            const clouds = hourly.cloudcover[idx];
            const wind_kmh = cw.windspeed;
            const pressure = hourly.surface_pressure[idx];
            const uv = hourly.uv_index[idx];
            const visibility_m = hourly.visibility[idx];
            const sunriseTime = new Date(daily.sunrise[0]).toLocaleTimeString([], { hour: 'numeric', minute:'2-digit' });
            const sunsetTime = new Date(daily.sunset[0]).toLocaleTimeString([], { hour: 'numeric', minute:'2-digit' });

            let tempDisplay, feelsDisplay, windDisplay, precipDisplay, visDisplay, windUnit = 'km/h', tempUnit = '¬∞C', visUnit = 'km';
            if (units === 'imperial') {
                tempDisplay = Math.round(cToF(tempC)); feelsDisplay = Math.round(cToF(feelsC)); windDisplay = Math.round(mpsToMph(wind_kmh / 3.6)); precipDisplay = (precip_mm * 0.0393701).toFixed(2); visDisplay = (visibility_m / 1609.34).toFixed(1);
                windUnit = 'mph'; tempUnit = '¬∞F'; visUnit = 'mi';
            } else {
                tempDisplay = Math.round(tempC); feelsDisplay = Math.round(feelsC); windDisplay = Math.round(wind_kmh); precipDisplay = precip_mm.toFixed(1); visDisplay = (visibility_m / 1000).toFixed(1);
            }

            $('temp').textContent = `${tempDisplay}${tempUnit}`;
            $('desc').textContent = mapWeatherCodeToText(cw.weathercode);
            $('loc').textContent = name || `Lat ${lat.toFixed(2)}, Lon ${lon.toFixed(2)}`;
            $('time').textContent = now.toLocaleString();
            $('wind').textContent = `${windDisplay} ${windUnit}`;
            $('precip').textContent = `${precipDisplay} ${units === 'imperial' ? 'in' : 'mm'}`;
            $('hum').textContent = `${hum}%`;
            $('clouds').textContent = `${clouds}%`;
            $('feels').textContent = `${feelsDisplay}${tempUnit}`;
            $('press').textContent = pressure ? `${pressure.toFixed(0)} hPa` : '--';
            $('uv').textContent = uv !== null ? uv.toFixed(1) : '--';
            $('vis').textContent = visibility_m !== null ? `${visDisplay} ${visUnit}` : '--';
            $('sunrise').textContent = sunriseTime;
            $('sunset').textContent = sunsetTime;
            
            const config = sportsConfig[selectedSport];
            const finalScore = calculatePlayability(hourly, config, idx);
            scoreEl.textContent = `Score: ${finalScore}/100`;
            $('reason').textContent = generateReasonText(hourly, config, idx);

            if (finalScore >= 80) { playBadge.textContent = "Good"; playBadge.style.backgroundColor = "#22c55e"; }
            else if (finalScore >= 50) { playBadge.textContent = "Fair"; playBadge.style.backgroundColor = "#eab308"; }
            else { playBadge.textContent = "Bad"; playBadge.style.backgroundColor = "#ef4444"; }
            
            $('play-windows').innerHTML = findPlayWindows(hourly, config, idx);

            renderRainAlert(hourly, idx);
            updateFavoriteButtonState();
            renderHourlyForecast(hourly, config, idx);
            renderForecast(data, config);
        }

        function mapWeatherCodeToText(code) {
            const map = { 0: 'Clear sky', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast', 45: 'Fog', 48: 'Depositing rime fog', 51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle', 56: 'Light freezing drizzle', 57: 'Dense freezing drizzle', 61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain', 66: 'Light freezing rain', 67: 'Heavy freezing rain', 71: 'Slight snow fall', 73: 'Moderate snow fall', 75: 'Heavy snow fall', 77: 'Snow grains', 80: 'Slight rain showers', 81: 'Moderate rain showers', 82: 'Violent rain showers', 85: 'Slight snow showers', 86: 'Heavy snow showers', 95: 'Thunderstorm', 96: 'Thunderstorm with slight hail', 99: 'Thunderstorm with heavy hail' };
            return map[code] || 'Unknown';
        }
        
        function getIconForWeatherCode(code) {
            if ([0, 1].includes(code)) return '‚òÄÔ∏è'; if ([2].includes(code)) return '‚õÖÔ∏è'; if ([3].includes(code)) return '‚òÅÔ∏è'; if ([45, 48].includes(code)) return 'üå´Ô∏è'; if ([51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82].includes(code)) return 'üåßÔ∏è'; if ([71, 73, 75, 77, 85, 86].includes(code)) return '‚ùÑÔ∏è'; if ([95, 96, 99].includes(code)) return '‚õàÔ∏è'; return '‚ùì';
        }
        
        function cToF(c) { return c * 9 / 5 + 32 }
        function mpsToMph(mps) { return mps * 2.23694 }

        function renderRainAlert(hourly, currentIndex) {
            const alertDiv = $('rain-alert');
            const nextHourPrecip = hourly.precipitation[currentIndex + 1];
            if (nextHourPrecip > 0.1) {
                const time = new Date(hourly.time[currentIndex + 1]).toLocaleTimeString([], { hour: 'numeric', minute:'2-digit' });
                alertDiv.textContent = `üíß Light rain expected to start around ${time}.`;
                alertDiv.style.display = 'block';
            } else {
                alertDiv.style.display = 'none';
            }
        }
        
        function renderHourlyForecast(hourlyData, config, startIndex) {
            const container = $('hourly-content');
            let html = '';
            const hoursToConsider = Math.min(startIndex + 24, hourlyData.time.length);
            for (let i = startIndex; i < hoursToConsider; i++) {
                const date = new Date(hourlyData.time[i]);
                const timeString = (i === startIndex) ? "Now" : date.toLocaleTimeString([], { hour: 'numeric' }).replace(/\s/g, '');
                const tempC = hourlyData.temperature_2m[i];
                let tempDisplay = (units === 'imperial') ? Math.round(cToF(tempC)) : Math.round(tempC);
                const tempUnit = (units === 'imperial') ? '¬∞F' : '¬∞C';
                const icon = getIconForWeatherCode(hourlyData.weathercode[i]);
                const score = calculatePlayability(hourlyData, config, i);
                let scoreColor = '#ef4444'; if (score >= 80) scoreColor = '#22c55e'; else if (score >= 50) scoreColor = '#eab308';
                html += `<div class="hourly-item"><div>${timeString}</div><div class="hourly-icon">${icon}</div><div>${tempDisplay}${tempUnit}</div><div class="hourly-score" style="background-color:${scoreColor}; color: white;">${score}</div></div>`;
            }
            container.innerHTML = html;
        }

        function getFavorites() { return JSON.parse(localStorage.getItem('weather_favorites')) || []; }
        function saveFavorites(favorites) { localStorage.setItem('weather_favorites', JSON.stringify(favorites)); }
        
        function isCurrentLocationFavorite() {
            if (!lastData || !lastData.name) return false;
            const favorites = getFavorites();
            return favorites.some(fav => fav.lat === lastData.lat && fav.lon === lastData.lon);
        }

        function saveCurrentFavorite() {
            if (!lastData || !lastData.name) return;
            const favorites = getFavorites();
            if (!isCurrentLocationFavorite()) {
                favorites.push({ name: lastData.name, lat: lastData.lat, lon: lastData.lon });
                saveFavorites(favorites);
                renderFavorites();
                updateFavoriteButtonState();
            }
        }
        
        function removeCurrentFavorite() {
            if (!lastData) return;
            let favorites = getFavorites();
            favorites = favorites.filter(fav => !(fav.lat === lastData.lat && fav.lon === lastData.lon));
            saveFavorites(favorites);
            renderFavorites();
            updateFavoriteButtonState();
        }

        function deleteFavorite(index) {
            let favorites = getFavorites();
            favorites.splice(index, 1);
            saveFavorites(favorites);
            renderFavorites();
            updateFavoriteButtonState();
        }
        
        function updateFavoriteButtonState() {
            const btn = $('save-fav-btn');
            if (!lastData || !lastData.name) {
                btn.style.display = 'none';
                return;
            }
            btn.style.display = 'inline-block';

            if (isCurrentLocationFavorite()) {
                btn.textContent = '‚òÖ';
                btn.title = 'Remove from favorites';
                btn.classList.add('is-favorite');
                btn.onclick = removeCurrentFavorite;
            } else {
                btn.textContent = '‚òÜ';
                btn.title = 'Save to favorites';
                btn.classList.remove('is-favorite');
                btn.onclick = saveCurrentFavorite;
            }
        }
        
        function renderFavorites() {
            const favorites = getFavorites();
            const container = $('favorites-section');
            if (favorites.length === 0) {
                container.innerHTML = '';
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';
            let html = `<h2 style="margin-top:0; margin-bottom: 12px;">Favorites</h2><div class="sport-list">`;
            favorites.forEach((fav, index) => {
                html += `<div><button class="btn" data-index="${index}">${fav.name}</button><button class="btn delete-btn" data-index="${index}">√ó</button></div>`;
            });
            html += `</div>`;
            container.innerHTML = html;
            container.querySelectorAll('.btn').forEach(btn => {
                const index = btn.dataset.index;
                if (btn.classList.contains('delete-btn')) {
                    btn.addEventListener('click', () => deleteFavorite(index));
                } else {
                    btn.addEventListener('click', () => {
                        const fav = getFavorites()[index];
                        if (fav) fetchWeather(fav.lat, fav.lon, fav.name);
                    });
                }
            });
        }

        function renderForecast(data, config) {
            const hourly = data.hourly || {};
            const times = hourly.time || [];
            if (!times.length) { forecastContent.textContent = 'Forecast data not available.'; return; }
            const dayGroups = {};
            times.forEach((t, i) => { const day = t.split('T')[0]; if (!dayGroups[day]) dayGroups[day] = []; dayGroups[day].push(i); });
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const pad = n => String(n).padStart(2, '0');
            const tomorrowStr = `${tomorrow.getFullYear()}-${pad(tomorrow.getMonth() + 1)}-${pad(tomorrow.getDate())}`;
            const days = Object.keys(dayGroups).filter(d => d >= tomorrowStr).slice(0, 3);
            if (days.length === 0) { forecastContent.innerHTML = 'Forecast for the next 3 days is not available.'; return; }
            let html = '';
            days.forEach(day => {
                const dayIndices = dayGroups[day];
                if (!dayIndices || dayIndices.length === 0) return;
                
                const viableIndices = dayIndices.filter(i => {
                    const hour = new Date(times[i]).getHours();
                    return hour >= 6 && hour <= 21;
                });

                let finalScore = 0;
                if (viableIndices.length > 0) {
                    const hourlyScores = viableIndices.map(i => calculatePlayability(hourly, config, i));
                    finalScore = Math.round(Math.max(...hourlyScores));
                }
                
                const dayTempsC = dayIndices.map(i => hourly.temperature_2m[i]).filter(t => t !== null && t !== undefined);
                if (dayTempsC.length === 0) return;

                const lowTempC = Math.min(...dayTempsC);
                const highTempC = Math.max(...dayTempsC);
                
                let noonIndex = dayIndices.find(i => times[i].endsWith('12:00')) ?? dayIndices[Math.floor(dayIndices.length / 2)];
                const precip_mm = hourly.precipitation?.[noonIndex] ?? 0;
                const wind_kmh = hourly.windspeed_10m?.[noonIndex] ?? 0;
                const uv = hourly.uv_index?.[noonIndex];
                let lowTempDisplay, highTempDisplay, tempUnit, windDisplay, windUnit, precipDisplay, precipUnit;
                if (units === 'imperial') {
                    lowTempDisplay = Math.round(cToF(lowTempC)); highTempDisplay = Math.round(cToF(highTempC)); tempUnit = '¬∞F';
                    windDisplay = Math.round(mpsToMph(wind_kmh / 3.6)); windUnit = 'mph';
                    precipDisplay = (precip_mm * 0.0393701).toFixed(2); precipUnit = 'in';
                } else {
                    lowTempDisplay = Math.round(lowTempC); highTempDisplay = Math.round(highTempC); tempUnit = '¬∞C';
                    windDisplay = Math.round(wind_kmh); windUnit = 'km/h';
                    precipDisplay = precip_mm.toFixed(1); precipUnit = 'mm';
                }
                const dateObj = new Date(day + 'T12:00:00');
                const dayStr = dateObj.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });
                let badgeText = '', badgeColor = '';
                if (finalScore >= 80) { badgeText = "Good"; badgeColor = "#22c55e"; }
                else if (finalScore >= 50) { badgeText = "Fair"; badgeColor = "#eab308"; }
                else { badgeText = "Bad"; badgeColor = "#ef4444"; }
                html += `<div class="forecast-day"><strong>${dayStr}</strong> - Score: ${finalScore}/100 <span style="background-color:${badgeColor};color:#fff;padding:2px 6px;border-radius:12px;margin-left:8px;">${badgeText}</span><div style="font-size:12px;color:#bbb;margin-top:4px;">Temp: ${highTempDisplay}/${lowTempDisplay}${tempUnit} &bull; Precip: ${precipDisplay} ${precipUnit} &bull; Wind: ${windDisplay} ${windUnit} &bull; UV: ${uv !== null && uv !== undefined ? uv.toFixed(1) : '--'}</div></div>`;
            });
            forecastContent.innerHTML = html;
        }

        getLocationAndFetch();
        renderFavorites();
    </script>
</body>

</html>
