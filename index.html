<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Weather4Sports
    </title>
    <style>
        :root {
            --bg: #0f1724;
            --card: #0b1220;
            --muted: #98a0b3;
            --accent: #4f46e5
        }

        * {
            box-sizing: border-box
        }

        body {
            font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
            margin: 0;
            background: linear-gradient(180deg, #071026 0%, #07172a 100%);
            color: #e6eef8;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px
        }

        .app {
            width: 100%;
            max-width: 900px
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 20px;
            margin: 0
        }

        p.lead {
            margin: 4px 0 0;
            color: var(--muted);
            font-size: 13px
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            border-radius: 14px;
            padding: 18px;
            margin-top: 18px;
            box-shadow: 0 6px 30px rgba(2, 6, 23, 0.6)
        }

        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            color: inherit;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer
        }

        .btn.primary {
            background: linear-gradient(90deg, var(--accent), #7c3aed);
            border: none
        }

        .row {
            display: flex;
            gap: 14px;
            flex-wrap: wrap
        }

        .col {
            flex: 1;
            min-width: 220px
        }

        .metric {
            display: flex;
            align-items: center;
            gap: 12px
        }

        .big {
            font-size: 36px;
            font-weight: 700
        }

        .muted {
            color: var(--muted)
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 12px;
            margin-top: 12px
        }

        .stat {
            background: rgba(255, 255, 255, 0.02);
            padding: 12px;
            border-radius: 10px;
            text-align: center
        }

        .rating {
            display: flex;
            gap: 10px;
            align-items: center
        }

        .pill {
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.03)
        }

        .sport-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px
        }

        .sport {
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.04)
        }

        .sport.active {
            background: rgba(79, 70, 229, 0.12);
            border-color: rgba(79, 70, 229, 0.3)
        }

        footer {
            margin-top: 12px;
            color: var(--muted);
            font-size: 13px
        }

        input[type="number"], input[type="text"] {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            background: transparent;
            color: inherit;
        }

        input[type="number"] { width: 120px; }
        input[type="text"] { width: 180px; }

        .error {
            color: #ffb4b4
        }

        @media (max-width:700px) {
            .stat-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        #forecast {
            margin-top: 24px;
        }
        #forecast h2 {
            margin-bottom: 8px;
        }
        .forecast-day {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 8px;
        }

        /* --- NEW: Styles for Hourly Forecast --- */
        #hourly-scroll-container {
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 12px;
        }
        #hourly-content {
            display: flex;
            gap: 12px;
        }
        .hourly-item {
            flex-shrink: 0;
            width: 75px;
            padding: 12px 8px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.03);
            text-align: center;
            font-size: 13px;
        }
        .hourly-icon {
            font-size: 24px;
            margin: 4px 0;
        }
        .hourly-score {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 999px;
            margin-top: 4px;
            font-weight: 500;
        }

        #hourly-scroll-container::-webkit-scrollbar {
            height: 6px;
        }
        #hourly-scroll-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        #hourly-scroll-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

    </style>
</head>

<body>
    <div class="app">
        <header>
            <div>
                <h1>Weather4Sports</h1>
                <p class="lead">Get sport-specific weather ratings for your location.</p>
            </div>
            <div class="controls">
                <input type="text" id="city-search" placeholder="Search for a city..." list="city-suggestions">
                <datalist id="city-suggestions"></datalist>
                <button class="btn" id="refresh">üîÑ My Location</button>
                <label class="pill muted">Units: <select id="units">
                        <option value="metric">Metric (¬∞C, km/h)</option>
                        <option value="imperial" selected>Imperial (¬∞F, mph)</option>
                    </select></label>
            </div>
        </header>

        <div class="card">
            <div class="row">
                <div class="col">
                    <div class="metric">
                        <div>
                            <div id="temp" class="big">--¬∞</div>
                            <div class="muted" id="desc">--</div>
                        </div>
                        <div style="margin-left:auto;text-align:right">
                            <div class="muted">Location</div>
                            <div id="loc">detecting‚Ä¶</div>
                            <div class="muted" style="font-size:12px" id="time">--</div>
                        </div>
                    </div>

                    <div class="stat-grid" id="stats">
                        <div class="stat">Wind<br><strong id="wind">--</strong></div>
                        <div class="stat">Precip<br><strong id="precip">--</strong></div>
                        <div class="stat">Humidity<br><strong id="hum">--</strong></div>
                        <div class="stat">Clouds<br><strong id="clouds">--</strong></div>
                        <div class="stat">Feels Like<br><strong id="feels">--</strong></div>
                        <div class="stat">Pressure<br><strong id="press">--</strong></div>
                        <div class="stat">UV Index<br><strong id="uv">--</strong></div>
                        <div class="stat">Visibility<br><strong id="vis">--</strong></div>
                    </div>

                </div>
                <div class="col">
                    <div class="muted">Sport</div>
                    <div class="sport-list" id="sports">
                        <div class="sport active" data-sport="basketball">üèÄ Basketball</div>
                        <div class="sport" data-sport="soccer">‚öΩ Soccer</div>
                        <div class="sport" data-sport="tennis">üéæ Tennis</div>
                        <div class="sport" data-sport="baseball">‚öæ Baseball</div>
                        <div class="sport" data-sport="running">üèÉ Running</div>
                    </div>

                    <div style="margin-top:12px">
                        <div class="muted">Playability</div>
                        <div style="display:flex;align-items:center;gap:12px;margin-top:8px">
                            <div id="play-badge" class="pill">--</div>
                            <div class="muted" id="score">Score: --/100</div>
                        </div>
                    </div>

                    <div style="margin-top:14px">
                        <div class="muted">Best Time to Play Today</div>
                        <div id="best-time" style="font-weight:bold; color: #a5f3fc; margin-top: 4px;">Analyzing...</div>
                    </div>

                </div>
            </div>

            <div id="hourly-forecast-section" class="card" style="padding-top: 12px;">
                <h2 style="margin-top:0; margin-bottom: 12px;">Hourly Forecast</h2>
                <div id="hourly-scroll-container">
                    <div id="hourly-content">
                        </div>
                </div>
            </div>

            <div id="forecast" class="card" style="margin-top: 24px;">
                <h2>3-Day Playability Forecast</h2>
                <div id="forecast-content">Loading forecast...</div>
            </div>

            <div style="margin-top:14px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
                <div class="muted">Manual coords</div>
                <input type="number" id="lat" placeholder="lat" step="0.0001">
                <input type="number" id="lon" placeholder="lon" step="0.0001">
                <button class="btn primary" id="apply-coords">Apply</button>
                <div id="status" style="margin-left:auto" class="muted">API: Open-Meteo</div>
            </div>

        </div>
    </div>

    <script>
        const $ = id => document.getElementById(id);
        const unitsSelect = $('units');
        const scoreEl = $('score');
        const playBadge = $('play-badge');
        const forecastContent = $('forecast-content');
        
        let units = unitsSelect.value;
        let lastData = null;

        const sportsConfig = {
            basketball: { weights: { temp: 0.4, wind: 0.2, humidity: 0.1, uv: 0.2, visibility: 0.1 }, idealTemp: [15, 28], precipPenaltyFactor: 0.25 },
            soccer:     { weights: { temp: 0.3, wind: 0.2, humidity: 0.1, clouds: 0.1, uv: 0.15, visibility: 0.15 }, idealTemp: [10, 25], precipPenaltyFactor: 1.5 },
            tennis:     { weights: { temp: 0.3, wind: 0.3, humidity: 0.1, uv: 0.15, visibility: 0.15 }, idealTemp: [12, 30], precipPenaltyFactor: 0.25 },
            baseball:   { weights: { temp: 0.3, wind: 0.2, humidity: 0.1, clouds: 0.1, uv: 0.1, visibility: 0.2 }, idealTemp: [12, 32], precipPenaltyFactor: 0.5 },
            running:    { weights: { temp: 0.4, wind: 0.2, humidity: 0.2, uv: 0.2 }, idealTemp: [8, 20], precipPenaltyFactor: 2.5 }
        };

        let selectedSport = 'basketball';

        unitsSelect.addEventListener('change', () => {
            units = unitsSelect.value;
            if (lastData) render(lastData);
        });

        document.querySelectorAll('.sport').forEach(el => el.addEventListener('click', () => {
            document.querySelectorAll('.sport').forEach(s => s.classList.remove('active'));
            el.classList.add('active');
            selectedSport = el.dataset.sport;
            if (lastData) render(lastData);
        }));

        $('refresh').addEventListener('click', getLocationAndFetch);
        $('apply-coords').addEventListener('click', () => {
            const lat = parseFloat($('lat').value);
            const lon = parseFloat($('lon').value);
            if (Number.isFinite(lat) && Number.isFinite(lon)) fetchWeather(lat, lon);
            else alert('Please enter valid coordinates.');
        });
        
        const searchInput = $('city-search');
        const suggestionsList = $('city-suggestions');

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }
        
        const handleSearchInput = async (event) => {
            const query = event.target.value;
            if (query.length < 3) {
                suggestionsList.innerHTML = '';
                return;
            }

            const selectedOption = Array.from(suggestionsList.options).find(opt => opt.value === query);
            if (selectedOption) {
                const lat = selectedOption.dataset.lat;
                const lon = selectedOption.dataset.lon;
                const name = selectedOption.dataset.name;
                fetchWeather(lat, lon, name);
                suggestionsList.innerHTML = '';
                searchInput.value = '';
                return;
            }

            try {
                const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5`;
                const response = await fetch(url);
                const data = await response.json();
                suggestionsList.innerHTML = '';
                if (data.results) {
                    data.results.forEach(location => {
                        const option = document.createElement('option');
                        const region = location.admin1 || '';
                        const country = location.country_code;
                        option.value = `${location.name}${region ? ', ' + region : ''}, ${country}`;
                        option.dataset.lat = location.latitude;
                        option.dataset.lon = location.longitude;
                        option.dataset.name = location.name;
                        suggestionsList.appendChild(option);
                    });
                }
            } catch (e) {
                console.error("Geocoding fetch failed:", e);
            }
        };

        searchInput.addEventListener('input', debounce(handleSearchInput, 300));

        function getLocationAndFetch() {
            if (!navigator.geolocation) {
                $('status').textContent = 'Geolocation unavailable.';
                return;
            }
            $('loc').textContent = 'Getting location‚Ä¶';
            navigator.geolocation.getCurrentPosition(
                pos => fetchWeather(pos.coords.latitude, pos.coords.longitude),
                err => {
                    $('status').textContent = 'Location denied.';
                    alert('Location access was denied. Please use the search bar or enter coordinates manually.');
                }
            );
        }

        async function fetchWeather(lat, lon, locationName = null) {
            $('status').textContent = 'Fetching weather‚Ä¶';
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,apparent_temperature,relativehumidity_2m,precipitation,cloudcover,windspeed_10m,surface_pressure,uv_index,visibility,weathercode&timezone=auto`;
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error('Weather API error');
                const data = await res.json();
                lastData = { data, lat, lon, name: locationName };
                render(lastData);
                $('status').textContent = `Updated ${new Date().toLocaleTimeString()}`;
            } catch (e) {
                console.error("Error during weather fetch or render:", e);
                $('status').textContent = 'Weather fetch or render failed.';
            }
        }
        
        function calculatePlayability(hourlyData, config, hourIndex) {
             if (hourIndex === undefined || hourIndex < 0 || !hourlyData) return 0;
             const requiredKeys = ['temperature_2m', 'precipitation', 'windspeed_10m', 'relativehumidity_2m', 'cloudcover', 'uv_index', 'visibility', 'weathercode'];
             if (requiredKeys.some(key => !hourlyData[key] || hourlyData[key].length <= hourIndex)) return 0;

             const tempC = hourlyData.temperature_2m[hourIndex];
             const precip_mm = hourlyData.precipitation[hourIndex];
             const wind_kmh = hourlyData.windspeed_10m[hourIndex];
             const hum = hourlyData.relativehumidity_2m[hourIndex];
             const clouds = hourlyData.cloudcover[hourIndex];
             const uv = hourlyData.uv_index[hourIndex];
             const visibility_m = hourlyData.visibility[hourIndex];
             const weatherCode = hourlyData.weathercode[hourIndex];

             if ([tempC, precip_mm, wind_kmh, hum, clouds, uv, visibility_m, weatherCode].some(v => v === undefined || v === null)) return 0;
             
             const dealBreakerCodes = [ 56, 57, 66, 67, 71, 73, 75, 77, 85, 86, 96, 99 ]; 
             const precipPenaltyFactor = config.precipPenaltyFactor || 2.0;
             let precipMultiplier = dealBreakerCodes.includes(weatherCode) ? 0 : Math.max(0, 1 - (precip_mm / precipPenaltyFactor));

             const runnableSnowCodes = [71, 73, 85];
             if (selectedSport === 'running' && runnableSnowCodes.includes(weatherCode)) {
                precipMultiplier = 0.3;
             }

             if (precipMultiplier === 0) return 0;

             let tempScore = 0;
             if (tempC < config.idealTemp[0]) tempScore = Math.max(0, 1 - (config.idealTemp[0] - tempC) / 15);
             else if (tempC > config.idealTemp[1]) tempScore = Math.max(0, 1 - (tempC - config.idealTemp[1]) / 15);
             else tempScore = 1;

             let windScore = wind_kmh > 35 ? 0 : 1 - wind_kmh / 35;
             let humScore = (hum >= 40 && hum <= 60) ? 1 : 1 - Math.min(Math.abs(hum - 50) / 50, 1);
             let cloudsScore = clouds > 100 ? 0 : 1 - clouds / 100;
             let uvScore = uv < 3 ? 1 : (uv > 11 ? 0 : 1 - ((uv - 3) / 8));
             const vis_km = visibility_m / 1000;
             let visibilityScore = vis_km > 10 ? 1 : (vis_km < 1 ? 0 : (vis_km - 1) / 9);
             
             let weightedSum = 0;
             let totalWeight = 0;
             for (const factor in config.weights) {
                let score = 0;
                if (factor === 'temp') score = tempScore;
                if (factor === 'wind') score = windScore;
                if (factor === 'humidity') score = humScore;
                if (factor === 'clouds') score = cloudsScore;
                if (factor === 'uv') score = uvScore;
                if (factor === 'visibility') score = visibilityScore;
                
                weightedSum += score * config.weights[factor];
                totalWeight += config.weights[factor];
             }
             
             const baseScore = totalWeight > 0 ? (weightedSum / totalWeight) : 1;
             const finalScore = baseScore * precipMultiplier;
             
             return Math.round(finalScore * 100);
        }

        function findBestTime(hourlyData, config, startIndex) {
            let bestHourIndex = -1;
            let highestScore = -1;
            
            if (!hourlyData.time || !hourlyData.time[startIndex]) return { time: null, score: 0 };
            
            const todayStr = hourlyData.time[startIndex].split('T')[0];

            for (let i = startIndex; i < hourlyData.time.length; i++) {
                const date = new Date(hourlyData.time[i]);
                const hour = date.getHours();
                const currentDayStr = hourlyData.time[i].split('T')[0];

                if (currentDayStr !== todayStr) {
                    break;
                }

                if (hour >= 6 && hour <= 21) {
                    const score = calculatePlayability(hourlyData, config, i);
                    if (score > highestScore) {
                        highestScore = score;
                        bestHourIndex = i;
                    }
                }
            }
            if (bestHourIndex === -1) return { time: null, score: 0 };
            return { time: hourlyData.time[bestHourIndex], score: highestScore };
        }

        function render(payload) {
            const { data, lat, lon, name } = payload;
            
            if (!data || !data.current_weather || !data.hourly || !data.hourly.time || data.hourly.time.length === 0) {
                $('status').textContent = 'Incomplete weather data received.';
                return;
            }
            
            const cw = data.current_weather;
            const hourly = data.hourly;
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const isoHour = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:00`;
            let idx = hourly.time.indexOf(isoHour);
            if (idx === -1) idx = 0;

            const tempC = hourly.temperature_2m[idx];
            const feelsC = hourly.apparent_temperature[idx];
            const hum = hourly.relativehumidity_2m[idx];
            const precip_mm = hourly.precipitation[idx];
            const clouds = hourly.cloudcover[idx];
            const wind_kmh = cw.windspeed;
            const pressure = hourly.surface_pressure[idx];
            const uv = hourly.uv_index[idx];
            const visibility_m = hourly.visibility[idx];

            let tempDisplay, feelsDisplay, windDisplay, precipDisplay, visDisplay, windUnit = 'km/h', tempUnit = '¬∞C', visUnit = 'km';
            if (units === 'imperial') {
                tempDisplay = Math.round(cToF(tempC)); feelsDisplay = Math.round(cToF(feelsC)); windDisplay = Math.round(mpsToMph(wind_kmh / 3.6)); precipDisplay = (precip_mm * 0.0393701).toFixed(2); visDisplay = (visibility_m / 1609.34).toFixed(1);
                windUnit = 'mph'; tempUnit = '¬∞F'; visUnit = 'mi';
            } else {
                tempDisplay = Math.round(tempC); feelsDisplay = Math.round(feelsC); windDisplay = Math.round(wind_kmh); precipDisplay = precip_mm.toFixed(1); visDisplay = (visibility_m / 1000).toFixed(1);
            }

            $('temp').textContent = `${tempDisplay}${tempUnit}`;
            $('desc').textContent = mapWeatherCodeToText(cw.weathercode);
            $('loc').textContent = name || `Lat ${lat.toFixed(2)}, Lon ${lon.toFixed(2)}`;
            $('time').textContent = now.toLocaleString();
            $('wind').textContent = `${windDisplay} ${windUnit}`;
            $('precip').textContent = `${precipDisplay} ${units === 'imperial' ? 'in' : 'mm'}`;
            $('hum').textContent = `${hum}%`;
            $('clouds').textContent = `${clouds}%`;
            $('feels').textContent = `${feelsDisplay}${tempUnit}`;
            $('press').textContent = pressure ? `${pressure.toFixed(0)} hPa` : '--';
            $('uv').textContent = uv !== null ? uv.toFixed(1) : '--';
            $('vis').textContent = visibility_m !== null ? `${visDisplay} ${visUnit}` : '--';
            
            const config = sportsConfig[selectedSport];
            const finalScore = calculatePlayability(hourly, config, idx);
            scoreEl.textContent = `Score: ${finalScore}/100`;

            if (finalScore >= 80) { playBadge.textContent = "Good"; playBadge.style.backgroundColor = "#22c55e"; }
            else if (finalScore >= 50) { playBadge.textContent = "Fair"; playBadge.style.backgroundColor = "#eab308"; }
            else { playBadge.textContent = "Bad"; playBadge.style.backgroundColor = "#ef4444"; }
            
            const bestTime = findBestTime(hourly, config, idx);
            if (bestTime.time) {
                const bestTimeDate = new Date(bestTime.time);
                $('best-time').innerHTML = `Today at ${bestTimeDate.toLocaleTimeString([], {hour: 'numeric', minute:'2-digit'})} (Score: ${bestTime.score})`;
            } else {
                $('best-time').textContent = 'No ideal time left today (6 AM - 9 PM).';
            }

            renderHourlyForecast(hourly, config, idx);
            renderForecast(data, config);
        }

        function mapWeatherCodeToText(code) {
            const map = { 0: 'Clear sky', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast', 45: 'Fog', 48: 'Depositing rime fog', 51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle', 56: 'Light freezing drizzle', 57: 'Dense freezing drizzle', 61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain', 66: 'Light freezing rain', 67: 'Heavy freezing rain', 71: 'Slight snow fall', 73: 'Moderate snow fall', 75: 'Heavy snow fall', 77: 'Snow grains', 80: 'Slight rain showers', 81: 'Moderate rain showers', 82: 'Violent rain showers', 85: 'Slight snow showers', 86: 'Heavy snow showers', 95: 'Thunderstorm', 96: 'Thunderstorm with slight hail', 99: 'Thunderstorm with heavy hail' };
            return map[code] || 'Unknown';
        }
        
        // --- NEW: Helper to get a simple icon for weather codes ---
        function getIconForWeatherCode(code) {
            if ([0, 1].includes(code)) return '‚òÄÔ∏è'; // Clear, Mainly Clear
            if ([2].includes(code)) return '‚õÖÔ∏è'; // Partly Cloudy
            if ([3].includes(code)) return '‚òÅÔ∏è'; // Overcast
            if ([45, 48].includes(code)) return 'üå´Ô∏è'; // Fog
            if ([51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82].includes(code)) return 'üåßÔ∏è'; // Drizzle, Rain
            if ([71, 73, 75, 77, 85, 86].includes(code)) return '‚ùÑÔ∏è'; // Snow
            if ([95, 96, 99].includes(code)) return '‚õàÔ∏è'; // Thunderstorm
            return '‚ùì';
        }
        
        function cToF(c) { return c * 9 / 5 + 32 }
        function mpsToMph(mps) { return mps * 2.23694 }
        
        // --- NEW: Renders the hourly forecast ---
        function renderHourlyForecast(hourlyData, config, startIndex) {
            const container = $('hourly-content');
            let html = '';
            const hoursToConsider = Math.min(startIndex + 24, hourlyData.time.length);
            
            for (let i = startIndex; i < hoursToConsider; i++) {
                const date = new Date(hourlyData.time[i]);
                const timeString = date.toLocaleTimeString([], { hour: 'numeric', hour12: true }).replace(' ', '');

                const tempC = hourlyData.temperature_2m[i];
                let tempDisplay, tempUnit;
                if (units === 'imperial') {
                    tempDisplay = Math.round(cToF(tempC));
                    tempUnit = '¬∞F';
                } else {
                    tempDisplay = Math.round(tempC);
                    tempUnit = '¬∞C';
                }

                const weatherCode = hourlyData.weathercode[i];
                const icon = getIconForWeatherCode(weatherCode);

                const score = calculatePlayability(hourlyData, config, i);
                let scoreColor = '#ef4444'; // Bad (red)
                if (score >= 80) scoreColor = '#22c55e'; // Good (green)
                else if (score >= 50) scoreColor = '#eab308'; // Fair (yellow)

                html += `
                    <div class="hourly-item">
                        <div>${timeString}</div>
                        <div class="hourly-icon">${icon}</div>
                        <div>${tempDisplay}${tempUnit}</div>
                        <div class="hourly-score" style="background-color:${scoreColor}; color: white;">${score}</div>
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        function renderForecast(data, config) {
            const hourly = data.hourly || {};
            const times = hourly.time || [];
            if (!times.length) { forecastContent.textContent = 'Forecast data not available.'; return; }
            const dayGroups = {};
            times.forEach((t, i) => { const day = t.split('T')[0]; if (!dayGroups[day]) dayGroups[day] = []; dayGroups[day].push(i); });
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const pad = n => String(n).padStart(2, '0');
            const tomorrowStr = `${tomorrow.getFullYear()}-${pad(tomorrow.getMonth() + 1)}-${pad(tomorrow.getDate())}`;
            const days = Object.keys(dayGroups).filter(d => d >= tomorrowStr).slice(0, 3);
            if (days.length === 0) { forecastContent.innerHTML = 'Forecast for the next 3 days is not available.'; return; }
            let html = '';
            days.forEach(day => {
                const dayIndices = dayGroups[day];
                if (!dayIndices || dayIndices.length === 0) return;
                
                const viableIndices = dayIndices.filter(i => {
                    const hour = new Date(times[i]).getHours();
                    return hour >= 6 && hour <= 21;
                });

                let finalScore = 0;
                if (viableIndices.length > 0) {
                    const hourlyScores = viableIndices.map(i => calculatePlayability(hourly, config, i));
                    finalScore = Math.round(Math.max(...hourlyScores));
                }
                
                const dayTempsC = dayIndices.map(i => hourly.temperature_2m[i]).filter(t => t !== null && t !== undefined);
                if (dayTempsC.length === 0) return;

                const lowTempC = Math.min(...dayTempsC);
                const highTempC = Math.max(...dayTempsC);
                
                let noonIndex = dayIndices.find(i => times[i].endsWith('12:00')) ?? dayIndices[Math.floor(dayIndices.length / 2)];
                const precip_mm = hourly.precipitation?.[noonIndex] ?? 0;
                const wind_kmh = hourly.windspeed_10m?.[noonIndex] ?? 0;
                const uv = hourly.uv_index?.[noonIndex];
                let lowTempDisplay, highTempDisplay, tempUnit, windDisplay, windUnit, precipDisplay, precipUnit;
                if (units === 'imperial') {
                    lowTempDisplay = Math.round(cToF(lowTempC)); highTempDisplay = Math.round(cToF(highTempC)); tempUnit = '¬∞F';
                    windDisplay = Math.round(mpsToMph(wind_kmh / 3.6)); windUnit = 'mph';
                    precipDisplay = (precip_mm * 0.0393701).toFixed(2); precipUnit = 'in';
                } else {
                    lowTempDisplay = Math.round(lowTempC); highTempDisplay = Math.round(highTempC); tempUnit = '¬∞C';
                    windDisplay = Math.round(wind_kmh); windUnit = 'km/h';
                    precipDisplay = precip_mm.toFixed(1); precipUnit = 'mm';
                }
                const dateObj = new Date(day + 'T12:00:00');
                const dayStr = dateObj.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });
                let badgeText = '', badgeColor = '';
                if (finalScore >= 80) { badgeText = "Good"; badgeColor = "#22c55e"; }
                else if (finalScore >= 50) { badgeText = "Fair"; badgeColor = "#eab308"; }
                else { badgeText = "Bad"; badgeColor = "#ef4444"; }
                html += `<div class="forecast-day"><strong>${dayStr}</strong> - Score: ${finalScore}/100 <span style="background-color:${badgeColor};color:#fff;padding:2px 6px;border-radius:12px;margin-left:8px;">${badgeText}</span><div style="font-size:12px;color:#bbb;margin-top:4px;">Temp: ${highTempDisplay}/${lowTempDisplay}${tempUnit} &bull; Precip: ${precipDisplay} ${precipUnit} &bull; Wind: ${windDisplay} ${windUnit} &bull; UV: ${uv !== null && uv !== undefined ? uv.toFixed(1) : '--'}</div></div>`;
            });
            forecastContent.innerHTML = html;
        }

        getLocationAndFetch();
    </script>
</body>

</html>
