<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Weather4Sports
    </title>
    <style>
        /* (same styles as before, omitted here for brevity) */
        :root {
            --bg: #0f1724;
            --card: #0b1220;
            --muted: #98a0b3;
            --accent: #4f46e5
        }

        * {
            box-sizing: border-box
        }

        body {
            font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;
            margin: 0;
            background: linear-gradient(180deg, #071026 0%, #07172a 100%);
            color: #e6eef8;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px
        }

        .app {
            width: 100%;
            max-width: 900px
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px
        }

        h1 {
            font-size: 20px;
            margin: 0
        }

        p.lead {
            margin: 4px 0 0;
            color: var(--muted);
            font-size: 13px
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            border-radius: 14px;
            padding: 18px;
            margin-top: 18px;
            box-shadow: 0 6px 30px rgba(2, 6, 23, 0.6)
        }

        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            color: inherit;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer
        }

        .btn.primary {
            background: linear-gradient(90deg, var(--accent), #7c3aed);
            border: none
        }

        .row {
            display: flex;
            gap: 14px;
            flex-wrap: wrap
        }

        .col {
            flex: 1;
            min-width: 220px
        }

        .metric {
            display: flex;
            align-items: center;
            gap: 12px
        }

        .big {
            font-size: 36px;
            font-weight: 700
        }

        .muted {
            color: var(--muted)
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 12px
        }

        .stat {
            background: rgba(255, 255, 255, 0.02);
            padding: 12px;
            border-radius: 10px;
            text-align: center
        }

        .rating {
            display: flex;
            gap: 10px;
            align-items: center
        }

        .pill {
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.03)
        }

        .sport-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px
        }

        .sport {
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.04)
        }

        .sport.active {
            background: rgba(79, 70, 229, 0.12);
            border-color: rgba(79, 70, 229, 0.3)
        }

        footer {
            margin-top: 12px;
            color: var(--muted);
            font-size: 13px
        }

        .explain {
            margin-top: 10px;
            color: var(--muted);
            font-size: 13px
        }

        input[type="number"] {
            width: 120px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            background: transparent;
            color: inherit
        }

        .error {
            color: #ffb4b4
        }

        @media (max-width:700px) {
            .stat-grid {
                grid-template-columns: repeat(2, 1fr)
            }
        }

        /* New styles for forecast */
        #forecast {
            margin-top: 24px;
        }
        #forecast h2 {
            margin-bottom: 8px;
        }
        .forecast-day {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 8px;
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <div>
                <h1>Weather4Sports</h1>
                <p class="lead">Tells you whether it's good, fair, or bad to play common sports where you are right now.</p>
            </div>
            <div class="controls">
                <button class="btn" id="refresh">üîÑ Refresh</button>
                <button class="btn" id="use-manual">üìç Enter coords</button>
                <button class="btn" id="export">üì• Export Report</button> <!-- New export button -->
                <label class="pill muted">Units: <select id="units">
                        <option value="metric">Metric (¬∞C, km/h)</option>
                        <option value="imperial">Imperial (¬∞F, mph)</option>
                    </select></label>
            </div>
        </header>

        <div class="card">
            <div class="row">
                <div class="col">
                    <div class="metric">
                        <div>
                            <div id="temp" class="big">--¬∞</div>
                            <div class="muted" id="desc">--</div>
                        </div>
                        <div style="margin-left:auto;text-align:right">
                            <div class="muted">Location</div>
                            <div id="loc">detecting‚Ä¶</div>
                            <div class="muted" style="font-size:12px" id="time">--</div>
                        </div>
                    </div>

                    <div class="stat-grid" id="stats">
                        <div class="stat">Wind<br><strong id="wind">--</strong></div>
                        <div class="stat">Precip<br><strong id="precip">--</strong></div>
                        <div class="stat">Humidity<br><strong id="hum">--</strong></div>
                        <div class="stat">Clouds<br><strong id="clouds">--</strong></div>
                        <div class="stat">Feels Like<br><strong id="feels">--</strong></div>
                        <div class="stat">Pressure<br><strong id="press">--</strong></div>
                    </div>

                </div>
                <div class="col">
                    <div class="muted">Sport</div>
                    <div class="sport-list" id="sports">
                        <div class="sport active" data-sport="basketball">üèÄ Basketball</div>
                        <div class="sport" data-sport="soccer">‚öΩ Soccer</div>
                        <div class="sport" data-sport="tennis">üéæ Tennis</div>
                        <div class="sport" data-sport="baseball">‚öæ Baseball</div>
                        <div class="sport" data-sport="running">üèÉ Running</div>
                    </div>

                    <div style="margin-top:12px">
                        <div class="muted">Playability</div>
                        <div style="display:flex;align-items:center;gap:12px;margin-top:8px">
                            <div id="play-badge" class="pill">--</div>
                            <div class="muted" id="score">Score: --/100</div>
                        </div>
                        <div class="explain" id="reason">--</div>
                    </div>

                </div>
            </div>

            <!-- New multi-day forecast section -->
            <div id="forecast" class="card" style="margin-top: 24px;">
                <h2>3-Day Playability Forecast</h2>
                <div id="forecast-content">Loading forecast...</div>
            </div>

            <div style="margin-top:14px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
                <div class="muted">Manual coords</div>
                <input type="number" id="lat" placeholder="lat" step="0.0001">
                <input type="number" id="lon" placeholder="lon" step="0.0001">
                <button class="btn primary" id="apply-coords">Apply</button>
                <div id="status" style="margin-left:auto" class="muted">API: Open-Meteo (no key)</div>
            </div>

            <footer>
                <div>How it works: app detects your location (or you enter coordinates), fetches current weather & hourly
                    details, then computes a sport-specific score using temperature, wind, precipitation, humidity, and
                    cloud/visibility basics. Use units toggle for preference.</div>
            </footer>
        </div>
    </div>

    <script>
        // Helper utilities
        const $ = id => document.getElementById(id);
        const unitsSelect = $('units');
        let units = unitsSelect.value; // 'metric' or 'imperial'

        unitsSelect.addEventListener('change', () => {
            units = unitsSelect.value;
            if (lastData) render(lastData);
        })

        const sportsConfig = {
            basketball: { weights: { temp: 0.35, precip: 0.3, wind: 0.15, humidity: 0.1, clouds: 0.1 }, idealTemp: [15, 28] }, // Celsius
            soccer: { weights: { temp: 0.3, precip: 0.35, wind: 0.15, humidity: 0.1, clouds: 0.1 }, idealTemp: [10, 25] },
            tennis: { weights: { temp: 0.25, precip: 0.4, wind: 0.2, humidity: 0.1, clouds: 0.05 }, idealTemp: [12, 30] },
            baseball: { weights: { temp: 0.35, precip: 0.3, wind: 0.15, humidity: 0.1, clouds: 0.1 }, idealTemp: [12, 32] },
            running: { weights: { temp: 0.35, precip: 0.15, wind: 0.2, humidity: 0.2, clouds: 0.1 }, idealTemp: [8, 20] }
        };

        let selectedSport = 'basketball';
        document.querySelectorAll('.sport').forEach(el => el.addEventListener('click', () => {
            document.querySelectorAll('.sport').forEach(s => s.classList.remove('active'));
            el.classList.add('active');
            selectedSport = el.dataset.sport;
            if (lastData) render(lastData);
        }))

        // UI elements
        const statusEl = $('status');
        const playBadge = $('play-badge');
        const reasonEl = $('reason');
        const scoreEl = $('score');
        const forecastContent = $('forecast-content');

        document.getElementById('refresh').addEventListener('click', () => {
            getLocationAndFetch();
        })
        document.getElementById('use-manual').addEventListener('click', () => {
            alert('Enter latitude and longitude in the boxes below and click Apply.');
        })
        document.getElementById('apply-coords').addEventListener('click', () => {
            const lat = parseFloat($('lat').value);
            const lon = parseFloat($('lon').value);
            if (Number.isFinite(lat) && Number.isFinite(lon)) {
                fetchWeather(lat, lon);
            } else {
                alert('Please enter valid coordinates (numbers).');
            }
        })

        // Export to CSV
        document.getElementById('export').addEventListener('click', () => {
            if (!lastData) {
                alert('No data to export yet.');
                return;
            }
            exportCSV(lastData);
        })

        // Geolocation with graceful fallback
        function getLocationAndFetch() {
            if (!navigator.geolocation) {
                statusEl.textContent = 'Geolocation unavailable ‚Äî enter coords manually.';
                return;
            }
            statusEl.textContent = 'Getting location‚Ä¶';
            navigator.geolocation.getCurrentPosition(pos => {
                const { latitude, longitude } = pos.coords;
                fetchWeather(latitude, longitude);
            }, err => {
                statusEl.textContent = 'Location denied ‚Äî enter coords manually.';
            }, { enableHighAccuracy: true, timeout: 8000 });
        }

        // Fetch weather from Open-Meteo (no API key)
        async function fetchWeather(lat, lon) {
            statusEl.textContent = 'Fetching weather‚Ä¶';
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,apparent_temperature,relativehumidity_2m,precipitation,cloudcover,windspeed_10m,surface_pressure&timezone=auto`;
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error('Weather API error');
                const data = await res.json();
                lastData = { data, lat, lon };
                render(lastData);
                statusEl.textContent = 'Updated just now';
            } catch (e) {
                console.error(e);
                statusEl.textContent = 'Weather fetch failed ‚Äî try again.';
            }
        }

        // Convert units
        function cToF(c) { return c * 9 / 5 + 32 }
        function mpsToMph(mps) { return mps * 2.23694 }
        function msToKmh(m) { return m * 3.6 }

        // Main render
        let lastData = null;

        function render(payload) {
            const { data, lat, lon } = payload;
            // Determine indices for current hour
            const cw = data.current_weather || {};

            // Find nearest hourly index by matching date-hour
            const hourly = data.hourly || {};
            const times = hourly.time || [];
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const isoHour = now.getFullYear() + "-" + (pad(now.getMonth() + 1)) + "-" + pad(now.getDate()) + "T" + pad(now.getHours()) + ":00";
            let idx = times.indexOf(isoHour);
            if (idx === -1) idx = 0;

            const tempC = (hourly.temperature_2m && hourly.temperature_2m[idx] != null) ? hourly.temperature_2m[idx] : cw.temperature;
            const feelsC = (hourly.apparent_temperature && hourly.apparent_temperature[idx] != null) ? hourly.apparent_temperature[idx] : tempC;
            const hum = (hourly.relativehumidity_2m && hourly.relativehumidity_2m[idx] != null) ? hourly.relativehumidity_2m[idx] : (hourly.relativehumidity_2m ? hourly.relativehumidity_2m[0] : null);
            const precip = (hourly.precipitation && hourly.precipitation[idx] != null) ? hourly.precipitation[idx] : 0;
            const clouds = (hourly.cloudcover && hourly.cloudcover[idx] != null) ? hourly.cloudcover[idx] : null;
            const wind_kmh = cw.windspeed ? cw.windspeed : (hourly.windspeed_10m && hourly.windspeed_10m[idx] ? hourly.windspeed_10m[idx] : null);
            const pressure = (hourly.surface_pressure && hourly.surface_pressure[idx] != null) ? hourly.surface_pressure[idx] : null;

            // Show in preferred units
            let tempDisplay = tempC; let feelsDisplay = feelsC; let windDisplay = wind_kmh; let precipDisplay = precip; let windUnit = 'km/h'; let tempUnit = '¬∞C';
            if (units === 'imperial') {
                tempDisplay = Math.round(cToF(tempC)); feelsDisplay = Math.round(cToF(feelsC)); windDisplay = Math.round(mpsToMph(wind_kmh / 3.6)); precipDisplay = Math.round(precip * 0.0393701 * 100) / 100; // mm to inches
                windUnit = 'mph'; tempUnit = '¬∞F';
            } else {
                tempDisplay = Math.round(tempC); feelsDisplay = Math.round(feelsC); windDisplay = Math.round(wind_kmh); precipDisplay = Math.round(precip * 10) / 10; // mm
            }

            $('temp').textContent = `${tempDisplay}${tempUnit}`;
            $('desc').textContent = mapWeatherCodeToText(cw.weathercode);
            $('loc').textContent = `Lat ${lat.toFixed(3)}, Lon ${lon.toFixed(3)}`;
            $('time').textContent = new Date().toLocaleString();

            $('wind').textContent = windDisplay + ' ' + windUnit;
            $('precip').textContent = (precipDisplay === null ? '--' : precipDisplay + (units === 'imperial' ? ' in' : ' mm'));
            $('hum').textContent = (hum === null ? '--' : hum + '%');
            $('clouds').textContent = (clouds === null ? '--' : clouds + '%');
            $('feels').textContent = `${feelsDisplay}${tempUnit}`;
            $('press').textContent = pressure ? (pressure.toFixed(0) + ' hPa') : '--';

            // Calculate playability score
            const config = sportsConfig[selectedSport];
            let score = 0;

            // Temperature score (0 to 1)
            let tempScore = 0;
            if (tempC < config.idealTemp[0]) tempScore = tempC / config.idealTemp[0];
            else if (tempC > config.idealTemp[1]) tempScore = 1 - (tempC - config.idealTemp[1]) / (50 - config.idealTemp[1]);
            else tempScore = 1;
            tempScore = Math.min(Math.max(tempScore, 0), 1);

            // Precipitation score (1 at 0mm, linearly to 0 at 2mm+)
            let precipScore = precip > 2 ? 0 : 1 - precip / 2;

            // Wind score (1 at 0km/h, down to 0 at 30km/h+)
            let windScore = wind_kmh > 30 ? 0 : 1 - wind_kmh / 30;

            // Humidity score (1 at 40-60%, down to 0 at 0 or 100%)
            let humScore = (hum >= 40 && hum <= 60) ? 1 : 1 - Math.min(Math.abs(hum - 50) / 50, 1);

            // Clouds score (simple 1 at 0-30%, down to 0 at 100%)
            let cloudsScore = clouds > 100 ? 0 : 1 - clouds / 100;

            score = (
                config.weights.temp * tempScore +
                config.weights.precip * precipScore +
                config.weights.wind * windScore +
                config.weights.humidity * humScore +
                config.weights.clouds * cloudsScore
            );

            let finalScore = Math.round(score * 100);
            scoreEl.textContent = `Score: ${finalScore}/100`;

            // Set badge
            if (finalScore >= 80) {
                playBadge.textContent = "Good";
                playBadge.style.backgroundColor = "#22c55e"; // green
            } else if (finalScore >= 50) {
                playBadge.textContent = "Fair";
                playBadge.style.backgroundColor = "#eab308"; // yellow
            } else {
                playBadge.textContent = "Bad";
                playBadge.style.backgroundColor = "#ef4444"; // red
            }

            reasonEl.innerHTML = generateReason(finalScore, tempC, precip, wind_kmh, hum, clouds, selectedSport);

            // Render multi-day forecast (next 3 days, midday hour for playability)
            renderForecast(data, config);

        }

        function mapWeatherCodeToText(code) {
            // Simplified mapping from Open-Meteo weather codes to text
            const map = {
                0: 'Clear sky',
                1: 'Mainly clear',
                2: 'Partly cloudy',
                3: 'Overcast',
                45: 'Fog',
                48: 'Depositing rime fog',
                51: 'Light drizzle',
                53: 'Moderate drizzle',
                55: 'Dense drizzle',
                56: 'Light freezing drizzle',
                57: 'Dense freezing drizzle',
                61: 'Slight rain',
                63: 'Moderate rain',
                65: 'Heavy rain',
                66: 'Light freezing rain',
                67: 'Heavy freezing rain',
                71: 'Slight snow fall',
                73: 'Moderate snow fall',
                75: 'Heavy snow fall',
                77: 'Snow grains',
                80: 'Slight rain showers',
                81: 'Moderate rain showers',
                82: 'Violent rain showers',
                85: 'Slight snow showers',
                86: 'Heavy snow showers',
                95: 'Thunderstorm',
                96: 'Thunderstorm with slight hail',
                99: 'Thunderstorm with heavy hail',
            };
            return map[code] || 'Unknown';
        }

        // Generate explanation based on conditions
        function generateReason(score, tempC, precip, wind, hum, clouds, sport) {
            const reasons = [];
            if (score >= 80) reasons.push("Weather is great for playing " + sport + ".");
            else if (score >= 50) reasons.push("Conditions are okay but watch for:");
            else reasons.push("Poor conditions due to:");

            if (tempC < sportsConfig[sport].idealTemp[0]) reasons.push(`Temperature too low (${Math.round(tempC)}¬∞C).`);
            if (tempC > sportsConfig[sport].idealTemp[1]) reasons.push(`Temperature too high (${Math.round(tempC)}¬∞C).`);
            if (precip > 0.5) reasons.push(`Precipitation present (${precip.toFixed(2)} mm).`);
            if (wind > 20) reasons.push(`Wind is strong (${Math.round(wind)} km/h).`);
            if (hum < 30 || hum > 70) reasons.push(`Humidity out of ideal range (${hum}%).`);
            if (clouds > 80) reasons.push(`Cloud cover is heavy (${clouds}%).`);

            return reasons.join(' ');
        }

        // Render multi-day forecast for 3 days
        function renderForecast(data, config) {
            const hourly = data.hourly || {};
            const times = hourly.time || [];

            if (!times.length) {
                forecastContent.textContent = 'Forecast data not available.';
                return;
            }

            // Group hourly data by day
            const dayGroups = {};

            times.forEach((t, i) => {
                const day = t.split('T')[0];
                if (!dayGroups[day]) dayGroups[day] = [];
                dayGroups[day].push(i);
            });

            // We want next 3 days including today, but only midday hours (12:00) for playability
            const today = new Date().toISOString().split('T')[0];
            const days = Object.keys(dayGroups).filter(d => d >= today).slice(0, 3);

            let html = '';
            days.forEach(day => {
                // Find 12:00 hour index or closest
                let noonIndex = dayGroups[day].find(i => times[i].endsWith('12:00'));
                if (noonIndex === undefined) noonIndex = dayGroups[day][Math.floor(dayGroups[day].length / 2)];

                const tempC = hourly.temperature_2m[noonIndex];
                const precip = hourly.precipitation[noonIndex];
                const wind_kmh = hourly.windspeed_10m[noonIndex];
                const hum = hourly.relativehumidity_2m[noonIndex];
                const clouds = hourly.cloudcover[noonIndex];

                // Playability calc same as main
                let tempScore = 0;
                if (tempC < config.idealTemp[0]) tempScore = tempC / config.idealTemp[0];
                else if (tempC > config.idealTemp[1]) tempScore = 1 - (tempC - config.idealTemp[1]) / (50 - config.idealTemp[1]);
                else tempScore = 1;
                tempScore = Math.min(Math.max(tempScore, 0), 1);

                let precipScore = precip > 2 ? 0 : 1 - precip / 2;
                let windScore = wind_kmh > 30 ? 0 : 1 - wind_kmh / 30;
                let humScore = (hum >= 40 && hum <= 60) ? 1 : 1 - Math.min(Math.abs(hum - 50) / 50, 1);
                let cloudsScore = clouds > 100 ? 0 : 1 - clouds / 100;

                let score = (
                    config.weights.temp * tempScore +
                    config.weights.precip * precipScore +
                    config.weights.wind * windScore +
                    config.weights.humidity * humScore +
                    config.weights.clouds * cloudsScore
                );

                const finalScore = Math.round(score * 100);

                // Format date nicely
                const dateObj = new Date(day);
                const dayStr = dateObj.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });

                let badgeText = '';
                let badgeColor = '';
                if (finalScore >= 80) {
                    badgeText = "Good";
                    badgeColor = "#22c55e";
                } else if (finalScore >= 50) {
                    badgeText = "Fair";
                    badgeColor = "#eab308";
                } else {
                    badgeText = "Bad";
                    badgeColor = "#ef4444";
                }

                html += `
                    <div class="forecast-day">
                        <strong>${dayStr}</strong> - Score: ${finalScore}/100 <span style="background-color:${badgeColor};color:#fff;padding:2px 6px;border-radius:12px;margin-left:8px;">${badgeText}</span>
                        <div style="font-size:12px;color:#bbb;margin-top:4px;">
                            Temp: ${Math.round(tempC)}¬∞C, Precip: ${precip} mm, Wind: ${Math.round(wind_kmh)} km/h, Humidity: ${hum}%, Clouds: ${clouds}%
                        </div>
                    </div>
                `;
            });

            forecastContent.innerHTML = html;
        }

        // Auto-refresh every 15 minutes
        setInterval(() => {
            if (lastData) {
                fetchWeather(lastData.lat, lastData.lon);
            }
        }, 15 * 60 * 1000);

        // Export CSV function
        function exportCSV(payload) {
            const { data, lat, lon } = payload;
            const cw = data.current_weather || {};
            const hourly = data.hourly || {};
            const times = hourly.time || [];

            // Compose CSV header and data
            const rows = [
                ['DateTime', 'Temperature(¬∞C)', 'Precipitation(mm)', 'Wind Speed(km/h)', 'Humidity(%)', 'Cloud Cover(%)']
            ];

            for (let i = 0; i < times.length; i++) {
                rows.push([
                    times[i],
                    hourly.temperature_2m[i],
                    hourly.precipitation[i],
                    hourly.windspeed_10m[i],
                    hourly.relativehumidity_2m[i],
                    hourly.cloudcover[i]
                ]);
            }

            // Add summary line for current playability and location
            rows.push([]);
            rows.push(['Location', `Lat: ${lat}`, `Lon: ${lon}`]);
            rows.push(['Sport', selectedSport]);
            rows.push(['Current Playability Score', scoreEl.textContent.replace('Score: ', '')]);
            rows.push(['Playability Rating', playBadge.textContent]);

            // Convert to CSV string
            let csvContent = rows.map(r => r.join(',')).join('\n');

            // Download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sports-weather-report-${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // On load: get location
        getLocationAndFetch();

    </script>
</body>

</html>
